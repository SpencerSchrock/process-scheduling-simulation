<html>
<STYLE type="text/css">
OL.withalpha { list-style-type: lower-alpha }
</STYLE>
<center>
<h3>CMPSC 122<br>
Spring 2016</h3>

<h3>Homework VI<br>
8 April 2016</h3>
</center>
This assignment provides an opportunity to work with
some of the other data structures taught in this course.
<p>
<h4>PROBLEM DESCRIPTION</h4>
In evaluating process scheduling policies, it is certainly
constructive to compare them to each other, using some
quantifiable measurement (such as Average Turnaround Time).
But comparing various implementations of a problem to each
other might not always be completely informative, if all
the implementations under consideration are very bad.
<p>
So, it would be also good to have some theoretical model
to compare to, to determine just how good they are.
For process scheduling, the theoretically best policy for
minimizing Average Turnaround Time is the Shortest Remaining
Time policy.
<p>
This policy favors processes with very short CPU bursts,
so they do not have to wait for the slower processes.
The shorter jobs would even be allowed to preempt the slower
ones, taking the CPU away from a process that currently is using it.
<p>
But the Remaining Time is a factor.  Certainly a 20-millisecond task
would be preferred over a 1000-millisecond task, but if that slower
one has already been running for awhile, and only has 10 milliseconds
remaining on its current burst, it is better to just let it complete
what it is doing.
<p>
<h4>ASSIGNMENT DETAIL:</h4>
Implement the Shortest Remaining Time policy as a new derived
class, BUT with BOTH of the following restrictions (there will
be minimal credit if either one is not followed).
<ul>
<li>
Your implementation may not use any linked list or tree structure
to organize its information (so may not use the <tt>readySet</tt>
that it inherits from the base class.)  You may assume there will be
no more than 20 processes active at any one time.
<li>
Your implementation must have a very efficient growth rate that is
(1) better then O(<em>n</em>) with respect to the number of processes and
(2) not O(<em>1</em>) with respect to a constant that is greater than the
number of processes (such as the 20 in the previous bullet point).
</ul>
<p>
Your new class will actually need access to all of the Process arrays
to choose which one to run next.  To maximize code reuse, you can remember
the arrays that were given when the scheduler first begins simulation,
and then use that information within the class:
<pre>
    private:
        Process **procs;        // this scheduler's way of getting to process in
fo

        // declare additional variables as needed here

    public:
        //  grabs the process information, and then runs the simulation
        void runScheduler( Process* tasks[], int arrival[], int size)
        {
            procs = tasks;
            Scheduler::runScheduler( tasks, arrival, size );
        }
</pre>
<p>
Insert two new public functions into "process.h" that return the value
of <tt>procId</tt> and <tt>remainingTime</tt> for this new class to use to make its decisions.
It may not manipulate these variables, but simply see what value they have.
<p>
Also, for some small credit, include a little discussion of your
results in the Message Box, as for Homework 5.  How effective were the
existing scheduling policies already implemented?   And how does
optimizing Average Turnaround Time affect Average Response Time?
<p>
<h3>EXTRA CREDIT OPTION:</h4>
Of course, the Shortest Remaining Time policy is not really practical,
because it no system can predict in advance how much CPU time will
actually be required.   To some extent, the Round Robin policy can
help with that, in that the faster jobs do not have to wait so long
as the slower ones, but it would be nice to take advantage of what
is learned.
<p>
One scheduling policy uses the idea of Feedback, where the past history
of a process influences its scheduling in the future.  Consider this
abstract model:
<p>
<ul>
<li>
The ready set is organized as four FIFO queues, where the first
three behave as a Round Robin policy with increasing allowances
(such as 25, 100, and 400 milliseconds).  The lowest queue uses
a normal First Come First Served policy.
<li>
Every new process is treated optimistically and assigned to the
fastest queue.
<li>
Any time a process uses up its allowance without completing its burst,
it is demoted to the next slower queue.
<li>
Any time a process completes its CPU burst in less than half of its allowed time, it is promoted to the next faster queue (when it makes its next CPU request).
Similarly, any process in the bottom queue would be given 400 milliseconds on its next burst, in case it starts to have shorter needs.
</ul>
NOTE: Your implementation will not exactly resemble this abstract model,
since it will still have the same limitations as the basic assignment
(no linked list implementation).  Also, be reasonably space efficient
and don't allocate a 4x20 two-dimensional array to represent four
queues of up to 20 elements.
